a[i] = 0
}
j = num+1
for (i in (num*(n.teams/2)+1):nrow(playing_stat)){
ht = playing_stat$HomeTeam[i]
at = playing_stat$AwayTeam[i]
past = form[ht,j]               # get past n results
h[i]=past                   # 1 index is most recent
past = form[at,j]               # get past n results.
a[i]=past                  # 1 index is most recent
if ((i %% (n.teams/2)) == 0){
j = j + 1
}
}
playing_stat[paste('HM',num,sep = "")] = h
playing_stat[paste('AM',num,sep = "")] = a
return(playing_stat)
}
add_form_df=function(playing_statistics){
amount.games=nrow(playing_statistics)
if(amount.games>=2*(n.teams/2)){playing_statistics = add_form(playing_statistics,1)}
if(amount.games>=3*(n.teams/2)){playing_statistics = add_form(playing_statistics,2)}
if(amount.games>=4*(n.teams/2)){playing_statistics = add_form(playing_statistics,3)}
if(amount.games>=5*(n.teams/2)){playing_statistics = add_form(playing_statistics,4)}
if(amount.games>=6*(n.teams/2)){playing_statistics = add_form(playing_statistics,5)}
if(amount.games>=11*(n.teams/2)){playing_statistics = add_form(playing_statistics,10)}
if(amount.games>=21*(n.teams/2)){playing_statistics = add_form(playing_statistics,20)}
return(playing_statistics)
}
add_form_same_venue = function(playing_statistics){
hmh1=vector(mode="numeric",nrow(playing_stat))
ama1=vector(mode="numeric",nrow(playing_stat))
for (i in (n.teams/2+1):nrow(playing_statistics)){
home=playing_statistics$HomeTeam[i]
away=playing_statistics$AwayTeam[i]
# subset data until the game, so it is easier to get the last game from this team
hist_data = playing_statistics[1:i,]
home_last_result=hist_data$FTR[tail(which(hist_data$HomeTeam==home),2)[1]]
away_last_result=hist_data$FTR[tail(which(hist_data$AwayTeam==away),2)[1]]
hmh1[i]=ifelse(home_last_result=='H',3,ifelse(home_last_result=='D',1,0))
ama1[i]=ifelse(away_last_result=='A',3,ifelse(away_last_result=='D',1,0))
}
playing_statistics['HMH1']=hmh1
playing_statistics['AMA1']=ama1
return(playing_statistics)
}
playing_stat = add_form_df(playing_stat)
playing_stat = add_form_same_venue(playing_stat)
distances=read.csv("yearly_updated_data/distances.csv",row.names = 1)
colnames(distances)=str_replace_all(colnames(distances), fixed("."), "")
rownames(distances)=str_replace_all(rownames(distances), fixed(" "), "")
get_distance=function(playing_statd){
Distance = rep(0,nrow(playing_statd))
for (i in 1:nrow(playing_statd)){
ht = playing_statd$HomeTeam[i]
at = playing_statd$AwayTeam[i]
Distance[i]=distances[ht,at]
}
playing_statd["Distance"] = Distance
return (playing_statd)
}
playing_stat=get_distance(playing_stat)
playing_stat['HTGD'] = as.numeric(unlist(playing_stat['HTGS'])) - as.numeric(unlist(playing_stat['HTGC']))
playing_stat['ATGD'] = as.numeric(unlist(playing_stat['ATGS'])) - as.numeric(unlist(playing_stat['ATGC']))
playing_stat['DiffPts'] = playing_stat['HTP'] - playing_stat['ATP']
playing_stat['DiffLP'] = playing_stat['HomeTeamLP'] - playing_stat['AwayTeamLP']
cols = c('HTGD','ATGD','DiffPts','HTP','ATP','HTS','ATS','HTST','ATST')
for (col in cols){
playing_stat[col] = as.numeric(unlist(playing_stat[col])) / as.numeric(unlist(playing_stat$MW))
}
write.csv(playing_stat,"ENG_final_dataset.csv")
dataf=read.csv("ENG_final_dataset.csv")
x_all = dataf[,-which(names(dataf)=='FTR')]
y_all = dataf['FTR']
cols = c('HTGD','ATGD','HTP','ATP','DiffLP','Distance','AwayAvgAge','HomeAvgAge','HomeAvgMV','AwayAvgMV','HTS','ATS','HTST','ATST','HM3','AM3','HM5','AM5','HM10','AM10','HMH1','AMA1')
x_all[cols] = scale(x_all[cols])
x_featured=x_all[,c('HTP', 'ATP','HTGD', 'ATGD',
"DiffPts",'HM3','AM3','HM5','AM5','HM10','AM10','HMH1','AMA1',
'DiffLP','Distance','AwayAvgAge','HomeAvgAge','HomeAvgMV','AwayAvgMV',
'HTS','ATS','HTST','ATST')]
df=cbind(x_featured,y_all)
df$FTRC=ifelse(df$FTR=="H",0,ifelse(df$FTR=="D",1,2))
dat=df[-which(names(df)=="FTR")]
set.seed(999)
fixtures.coming=c((nrow(dat)-9):nrow(dat))
train_index <- dat[-fixtures.coming,]
data_variables <- as.matrix(dat[,-which(names(dat)=="FTRC")])
data_label <- dat[,"FTRC"]
data_matrix <- xgb.DMatrix(data = as.matrix(dat), label = data_label)
train_data   <- data_variables[-fixtures.coming,]
train_label  <- data_label[-fixtures.coming]
train_matrix <- xgb.DMatrix(data = train_data, label = train_label)
predict_data  <- data_variables[fixtures.coming,]
predict_label <- data_label[fixtures.coming]
predict_matrix <- xgb.DMatrix(data = predict_data, label = predict_label)
numberOfClasses <- length(unique(dat$FTRC))
xgb_params <- list("max_depth"=3,"eta"=0.2,
"colsample_bytree"=0.9,
"objective" = "multi:softprob",
"eval_metric" = "mlogloss",
"min_child_weight"=7,
"subsample"=0.8,
"alpha"=0,
"lambda"=1,
"num_class" = numberOfClasses)
nround    <- 20 # number of XGBoost rounds
cv.nfold  <- 10
bst_model <- xgb.train(params = xgb_params,
data = train_matrix,
nrounds = nround)
test_pred <- predict(bst_model, newdata = predict_matrix)
test_prediction <- matrix(test_pred, nrow = numberOfClasses,
ncol=length(test_pred)/numberOfClasses) %>%
t() %>%
data.frame() %>%
mutate(max_prob = max.col(., "last"))
test_prediction[,c("Date","HomeTeam","AwayTeam")]=x_all[fixtures.coming,c("Date","HomeTeam","AwayTeam")]
test_prediction$HomeTeam=as.character(test_prediction$HomeTeam)
test_prediction$AwayTeam=as.character(test_prediction$AwayTeam)
names(test_prediction)[c(1:3)]=c("Home","Draw","Away")
test_prediction$PredictedOutcome=ifelse(test_prediction$max_prob==1,test_prediction$HomeTeam,ifelse(test_prediction$max_prob==3,test_prediction$AwayTeam,"Draw"))
test_prediction$Homeodd=1/test_prediction$Home
test_prediction$Drawodd=1/test_prediction$Draw
test_prediction$Awayodd=1/test_prediction$Away
bf_odds = give_bf_odds('ENG')
bf_odds = bf_odds[1:10,]
bf_odds = data.frame(bf_odds)
test_prediction = data.frame(test_prediction[,c("HomeTeam","AwayTeam","PredictedOutcome","Homeodd","Drawodd","Awayodd")])
real_and_predicted = merge(x = bf_odds, y = test_prediction, by = c("HomeTeam","AwayTeam"), all.x = TRUE)
pred_real_oddratio = real_and_predicted[,c("BF_H_odds","BF_D_odds","BF_A_odds")]/real_and_predicted[,c("Homeodd","Drawodd","Awayodd")]
best_ratio = apply(pred_real_oddratio,1,max)
best_ratio_outcome = max.col(pred_real_oddratio)
best_ratio_outcome = ifelse(best_ratio_outcome == 1, "H",ifelse(best_ratio_outcome == 2,"D","A"))
real_and_predicted = real_and_predicted[,c("Date","HomeTeam","AwayTeam","PredictedOutcome","Homeodd","Drawodd","Awayodd",
"BF_H_odds","BF_D_odds","BF_A_odds")]
real_and_predicted = cbind(real_and_predicted,best_ratio,best_ratio_outcome)
real_and_predicted = real_and_predicted[order(real_and_predicted$Date),]
write.csv(real_and_predicted,paste("predictions_per_MW/prediction_MW",(nrow(dataf) %% 380)/10,"_",as.Date(tail(dataf$Date,n=1),"%d/%m/%y"),".csv",sep = ""))
setwd("D:/Het Project/Voetbal predictions/Premier-League")
used.packages=c("xgboost","stringr","qlcMatrix","e1071")
not.installed=!(used.packages %in% rownames(installed.packages()))
if(length(used.packages[not.installed])>0){
install.packages(used.packages[not.installed])
}
library("xgboost")  # the main algorithm
library("caret")    # for the confusionmatrix() function (also needs e1071 package)
library("dplyr")    # for some data preperation
library("stringr")
library("DiagrammeR")
library("qlcMatrix")
if(!exists("foo", mode="function")) source("ENG_db_updating.R")
if(!exists("foo", mode="function")) source("ENG_exp_lineups_V2.R")
if(!exists("foo", mode="function")) source("ENG_cleaningandpreparing.R")
if(!exists("foo", mode="function")) source("ENG_db_connection.R")
if(!exists("foo", mode="function")) source("give_bf_odds.R")
# Before starting the ENG_db_updating function we need to make sure the internet connection is good
#If not this will end in an error halfway updating the DB, meaning we have to delete rows in some tables manually
# First update the db
ENG_db_updating()
# import and prepare the data and eventually save it as csv
ENG_preparation(FALSE)
# download that csv for further use and prediction
dataf=read.csv("ENG_final_dataset.csv")
# Separate into feature set and target variable
#FTR = Full Time Result (H=Home Win, D=Draw, A=Away Win)
x_all = dataf[,-which(names(dataf)=='FTR')]
y_all = dataf['FTR']
#Standardising the data
#Center to the mean and component wise scale to unit variance.
cols = c('HTGD','ATGD','HTP','ATP','DiffLP','Distance','AwayAvgAge','HomeAvgAge','HomeAvgMV','AwayAvgMV','HTS','ATS','HTST','ATST','HM3','AM3','HM5','AM5','HM10','AM10','HMH1','AMA1')
x_all[cols] = scale(x_all[cols])
x_featured=x_all[,c('HTP', 'ATP','HTGD', 'ATGD',
"DiffPts",'HM3','AM3','HM5','AM5','HM10','AM10','HMH1','AMA1',
'DiffLP','Distance','AwayAvgAge','HomeAvgAge','HomeAvgMV','AwayAvgMV',
'HTS','ATS','HTST','ATST')]
df=cbind(x_featured,y_all)
# FTR naar cijfers converteren, beginnend met 0
df$FTRC=ifelse(df$FTR=="H",0,ifelse(df$FTR=="D",1,2))
dat=df[-which(names(df)=="FTR")]
# set seed for reproducibility
set.seed(999)
# Make split index based on the last ten rows are the coming matches
fixtures.coming=c((nrow(dat)-9):nrow(dat))
train_index <- dat[-fixtures.coming,]
# Full data set
data_variables <- as.matrix(dat[,-which(names(dat)=="FTRC")])
data_label <- dat[,"FTRC"]
data_matrix <- xgb.DMatrix(data = as.matrix(dat), label = data_label)
# split train data and make xgb.DMatrix
train_data   <- data_variables[-fixtures.coming,]
train_label  <- data_label[-fixtures.coming]
train_matrix <- xgb.DMatrix(data = train_data, label = train_label)
# split test data and make xgb.DMatrix
predict_data  <- data_variables[fixtures.coming,]
predict_label <- data_label[fixtures.coming]
predict_matrix <- xgb.DMatrix(data = predict_data, label = predict_label)
numberOfClasses <- length(unique(dat$FTRC))
xgb_params <- list("max_depth"=3,"eta"=0.2,
"colsample_bytree"=0.9,
"objective" = "multi:softprob",
"eval_metric" = "mlogloss",
"min_child_weight"=7,
"subsample"=0.8,
"alpha"=0,
"lambda"=1,
"num_class" = numberOfClasses)
nround    <- 20 # number of XGBoost rounds
cv.nfold  <- 10
bst_model <- xgb.train(params = xgb_params,
data = train_matrix,
nrounds = nround)
# Predict hold-out test set
test_pred <- predict(bst_model, newdata = predict_matrix)
test_prediction <- matrix(test_pred, nrow = numberOfClasses,
ncol=length(test_pred)/numberOfClasses) %>%
t() %>%
data.frame() %>%
mutate(max_prob = max.col(., "last"))
test_prediction[,c("Date","HomeTeam","AwayTeam")]=x_all[fixtures.coming,c("Date","HomeTeam","AwayTeam")]
test_prediction$HomeTeam=as.character(test_prediction$HomeTeam)
test_prediction$AwayTeam=as.character(test_prediction$AwayTeam)
names(test_prediction)[c(1:3)]=c("Home","Draw","Away")
test_prediction$PredictedOutcome=ifelse(test_prediction$max_prob==1,test_prediction$HomeTeam,ifelse(test_prediction$max_prob==3,test_prediction$AwayTeam,"Draw"))
test_prediction$Homeodd=1/test_prediction$Home
test_prediction$Drawodd=1/test_prediction$Draw
test_prediction$Awayodd=1/test_prediction$Away
# Using BF odds to see wat the best bet is
bf_odds = give_bf_odds('ENG')
bf_odds = bf_odds[1:10,]
bf_odds = data.frame(bf_odds)
test_prediction = data.frame(test_prediction[,c("HomeTeam","AwayTeam","PredictedOutcome","Homeodd","Drawodd","Awayodd")])
real_and_predicted = merge(x = bf_odds, y = test_prediction, by = c("HomeTeam","AwayTeam"), all.x = TRUE)
pred_real_oddratio = real_and_predicted[,c("BF_H_odds","BF_D_odds","BF_A_odds")]/real_and_predicted[,c("Homeodd","Drawodd","Awayodd")]
best_ratio = apply(pred_real_oddratio,1,max)
best_ratio_outcome = max.col(pred_real_oddratio)
best_ratio_outcome = ifelse(best_ratio_outcome == 1, "H",ifelse(best_ratio_outcome == 2,"D","A"))
real_and_predicted = real_and_predicted[,c("Date","HomeTeam","AwayTeam","PredictedOutcome","Homeodd","Drawodd","Awayodd",
"BF_H_odds","BF_D_odds","BF_A_odds")]
real_and_predicted = cbind(real_and_predicted,best_ratio,best_ratio_outcome)
real_and_predicted = real_and_predicted[order(real_and_predicted$Date),]
write.csv(real_and_predicted,paste("predictions_per_MW/prediction_MW",(nrow(dataf) %% 380)/10,"_",as.Date(head(dataf$Date,n=1),"%d/%m/%y"),".csv",sep = ""))
ENG_exp_lineups_V2 <- function(){
library(XML)
library(rvest)
library(RCurl)
library(httr)
exp_matches_lineups=setNames(data.frame(matrix(ncol = 25, nrow = 0)), c("match_date","hometeam","awayteam","h1","h2","h3","h4","h5","h6","h7","h8","h9","h10","h11","a1","a2","a3","a4","a5","a6","a7","a8","a9","a10","a11"))
# Overview of the expected lineups in a league
exp_url <- paste0("https://www.rotowire.com/soccer/soccer-lineups.htm")
geturl <- getURL(exp_url)
# get the html text behind it
exp_rawpage <- htmlTreeParse(geturl, useInternalNodes = TRUE)
# look for the sentence where the distance is included
exp_lineup_tables <- xpathSApply(exp_rawpage, "//div[@class='span15 offset1']//div[@class='span15 dlineups-datestatus']",xmlValue)
# getting all the data for all the 10 next games
exp_lineup_matchdate <- xpathSApply(exp_rawpage, '//div[@class="span5 dlineups-bigtimeonly"]//span',xmlValue)
exp_lineup_teams <- xpathSApply(exp_rawpage, '//div[@class="span15 dlineups-teamsnba"]',xmlValue)
# Get the title of the names, because the name shown on the page is sometimes shortened for the first name
exp_lineup_home <- xpathSApply(exp_rawpage, '//div[@class="home_lineup"]//div[@class="dlineups-vplayer"]//a', xmlGetAttr, "title")
exp_lineup_away <- xpathSApply(exp_rawpage, '//div[@class="visit_lineup"]//div[@class="dlineups-vplayer"]//a',xmlGetAttr, "title")
# line up split per game
line_ups_home <- matrix(exp_lineup_home, ncol = 11, byrow = TRUE)
line_ups_away <- matrix(exp_lineup_away, ncol = 11, byrow = TRUE)
# team names are in string e.g. "/t/tArsenal - Tottenham/t/t/" so we have to split up on the dash and look at both pieces seperately
url.names=c("Arsenal","Aston Villa","Birmingham","Blackburn","Blackpool","Bolton","Bournemouth","Bradford City","Brighton","Burnley","Cardiff","Charlton","Chelsea","Coventry City","Crystal Palace","Derby","Everton","Fulham","Huddersfield","Hull City","Ipswich","Leeds","Leicester","Liverpool","Manchester City","Manchester United","Middlesbrough","Newcastle","Norwich","Portsmouth FC","QPR","Reading","Sheffield Utd.","Southampton","Stoke","Sunderland","Swansea","Tottenham","Watford","West Brom","West Ham","Wigan","Wolves","Wimbledon")
team.names=c("Arsenal","Aston Villa","Birmingham","Blackburn","Blackpool","Bolton","Bournemouth","Bradford","Brighton","Burnley","Cardiff","Charlton","Chelsea","Coventry","Crystal Palace","Derby","Everton","Fulham","Huddersfield","Hull","Ipswich","Leeds","Leicester","Liverpool","Man City","Man United","Middlesbrough","Newcastle","Norwich","Portsmouth","QPR","Reading","Sheffield United","Southampton","Stoke","Sunderland","Swansea","Tottenham","Watford","West Brom","West Ham","Wigan","Wolves","Wimbledon")
splitted_teams <- strsplit(exp_lineup_teams,"vs.")
playing_teams <- matrix(vector(mode="character", length = 2*length(splitted_teams)),ncol = 2)
for (i in 1:length(splitted_teams)){
# Matches already played will look like t/tArsenal - Tottenham 2-0/t/t/ splitting on the dash will give more than 2 pieces
if (length(splitted_teams[[i]])==2){
for (n in 1:2){
playing_teams[i,n]=team.names[sapply(url.names, grepl, splitted_teams[[i]][n])]
}
}
}
# all the matches for which the expected line up is given on this page (always 10??)
date_time_match <- as.numeric(gsub("[^\\d]+", "", exp_lineup_matchdate, perl=TRUE))
day <- date_time_match
year <- rep(format(Sys.Date(),"%Y"),length(exp_lineup_matchdate))
months_all=c("January","February","March","April","May","June","July","August","September","October","November","December")
month <- vector(mode = "numeric", length = length(exp_lineup_matchdate))
for (i in 1:length(exp_lineup_matchdate)){
month[i] <- as.numeric(which(sapply(months_all, function(x) grepl(x, exp_lineup_matchdate[i]))))
}
# putting the year, month and day together and put it in date format
match_date=format(as.Date(paste(year,month,day, sep = "-"),"%Y-%m-%d"))
exp_matches_lineups <- rbind(exp_matches_lineups,cbind(match_date,playing_teams,line_ups_home,line_ups_away))
# Add column names again to be sure
colnames(exp_matches_lineups) <- c("match_date","hometeam","awayteam","h1","h2","h3","h4","h5","h6","h7","h8","h9","h10","h11","a1","a2","a3","a4","a5","a6","a7","a8","a9","a10","a11")
# because of the logic of splitting team names string we can exclude the rows in which there is no team name
exp_matches_lineups <- exp_matches_lineups[!is.na(exp_matches_lineups[,1]),]
return(exp_matches_lineups)
}
library(XML)
library(rvest)
library(RCurl)
library(httr)
exp_matches_lineups=setNames(data.frame(matrix(ncol = 25, nrow = 0)), c("match_date","hometeam","awayteam","h1","h2","h3","h4","h5","h6","h7","h8","h9","h10","h11","a1","a2","a3","a4","a5","a6","a7","a8","a9","a10","a11"))
exp_url <- paste0("https://www.rotowire.com/soccer/soccer-lineups.htm")
geturl <- getURL(exp_url)
exp_rawpage <- htmlTreeParse(geturl, useInternalNodes = TRUE)
exp_lineup_tables <- xpathSApply(exp_rawpage, "//div[@class='span15 offset1']//div[@class='span15 dlineups-datestatus']",xmlValue)
exp_lineup_matchdate <- xpathSApply(exp_rawpage, '//div[@class="span5 dlineups-bigtimeonly"]//span',xmlValue)
exp_lineup_teams <- xpathSApply(exp_rawpage, '//div[@class="span15 dlineups-teamsnba"]',xmlValue)
exp_lineup_home <- xpathSApply(exp_rawpage, '//div[@class="home_lineup"]//div[@class="dlineups-vplayer"]//a', xmlGetAttr, "title")
exp_lineup_away <- xpathSApply(exp_rawpage, '//div[@class="visit_lineup"]//div[@class="dlineups-vplayer"]//a',xmlGetAttr, "title")
line_ups_home <- matrix(exp_lineup_home, ncol = 11, byrow = TRUE)
line_ups_away <- matrix(exp_lineup_away, ncol = 11, byrow = TRUE)
url.names=c("Arsenal","Aston Villa","Birmingham","Blackburn","Blackpool","Bolton","Bournemouth","Bradford City","Brighton","Burnley","Cardiff","Charlton","Chelsea","Coventry City","Crystal Palace","Derby","Everton","Fulham","Huddersfield","Hull City","Ipswich","Leeds","Leicester","Liverpool","Manchester City","Manchester United","Middlesbrough","Newcastle","Norwich","Portsmouth FC","QPR","Reading","Sheffield Utd.","Southampton","Stoke","Sunderland","Swansea","Tottenham","Watford","West Brom","West Ham","Wigan","Wolves","Wimbledon")
team.names=c("Arsenal","Aston Villa","Birmingham","Blackburn","Blackpool","Bolton","Bournemouth","Bradford","Brighton","Burnley","Cardiff","Charlton","Chelsea","Coventry","Crystal Palace","Derby","Everton","Fulham","Huddersfield","Hull","Ipswich","Leeds","Leicester","Liverpool","Man City","Man United","Middlesbrough","Newcastle","Norwich","Portsmouth","QPR","Reading","Sheffield United","Southampton","Stoke","Sunderland","Swansea","Tottenham","Watford","West Brom","West Ham","Wigan","Wolves","Wimbledon")
splitted_teams <- strsplit(exp_lineup_teams,"vs.")
playing_teams <- matrix(vector(mode="character", length = 2*length(splitted_teams)),ncol = 2)
for (i in 1:length(splitted_teams)){
# Matches already played will look like t/tArsenal - Tottenham 2-0/t/t/ splitting on the dash will give more than 2 pieces
if (length(splitted_teams[[i]])==2){
for (n in 1:2){
playing_teams[i,n]=team.names[sapply(url.names, grepl, splitted_teams[[i]][n])]
}
}
}
date_time_match <- as.numeric(gsub("[^\\d]+", "", exp_lineup_matchdate, perl=TRUE))
day <- date_time_match
year <- rep(format(Sys.Date(),"%Y"),length(exp_lineup_matchdate))
months_all=c("January","February","March","April","May","June","July","August","September","October","November","December")
month <- vector(mode = "numeric", length = length(exp_lineup_matchdate))
for (i in 1:length(exp_lineup_matchdate)){
month[i] <- as.numeric(which(sapply(months_all, function(x) grepl(x, exp_lineup_matchdate[i]))))
}
exp_lineup_matchdate
date_time_match
xpathSApply(exp_rawpage, '//div[@class="span5 dlineups-bigtimeonly"]//span',xmlValue)
exp_lineup_teams
exp_lineup_home
setwd("D:/Het Project/Voetbal predictions/Bundesliga")
used.packages=c("xgboost","stringr","qlcMatrix","rBayesianOptimization","mailR","rJava","e1071")
not.installed=!(used.packages %in% rownames(installed.packages()))
if(length(used.packages[not.installed])>0){
install.packages(used.packages[not.installed])
}
library("xgboost")  # the main algorithm
library("caret")    # for the confusionmatrix() function (also needs e1071 package)
library("dplyr")    # for some data preperation
library("stringr")
library("DiagrammeR")
library("qlcMatrix")
library("rBayesianOptimization")
library("mailR")
library("rJava")
if(!exists("foo", mode="function")) source("DE_cleaningandpreparing.R")
# import and prepare the data and eventually save it as csv
DE_preparation(TRUE)
setwd("D:/Het Project/Voetbal predictions/Premier-League")
library(rvest)
library(XML)
library(RCurl)
library("RSQLite")
library(DBI)
url.names=c("Arsenal","Aston Villa","Birmingham","Blackburn","Blackpool","Bolton","AFC Bournemouth","Bradford City","Brighton and Hove Albion","Burnley","Cardiff","Charlton","Chelsea","Coventry City","Crystal Palace","Derby","Everton","Fulham","Huddersfield Town","Hull City","Ipswich","Leeds","Leicester City","Liverpool","Manchester City","Manchester United","Middlesbrough","Newcastle United","Norwich","Portsmouth FC","QPR","Reading","Sheffield Utd.","Southampton","Stoke City","Sunderland","Swansea City","Tottenham Hotspur","Watford","West Bromwich Albion","West Ham United","Wigan","Wolves","Wimbledon")
team.names=c("Arsenal","Aston Villa","Birmingham","Blackburn","Blackpool","Bolton","Bournemouth","Bradford","Brighton","Burnley","Cardiff","Charlton","Chelsea","Coventry","Crystal Palace","Derby","Everton","Fulham","Huddersfield","Hull","Ipswich","Leeds","Leicester","Liverpool","Man City","Man United","Middlesbrough","Newcastle","Norwich","Portsmouth","QPR","Reading","Sheffield United","Southampton","Stoke","Sunderland","Swansea","Tottenham","Watford","West Brom","West Ham","Wigan","Wolves","Wimbledon")
con = dbConnect(RSQLite::SQLite(), dbname="historic_data/football.db")
last_game_in_db <- as.numeric(dbGetQuery(con,'SELECT
COUNT(*)
FROM
"2017"'))
last_game_in_db
raw.data.18 = read.csv("http://www.football-data.co.uk/mmz4281/1718/E0.csv")
raw.data.18$Date = as.Date(raw.data.18$Date,"%d/%m/%y")
raw.data.18 = raw.data.18[order(raw.data.18$Date,raw.data.18$HomeTeam),]
raw.data.18$Date <- as.character(raw.data.18$Date)
last_game_available <- nrow(raw.data.18)
last_game_available
last_game_in_db <- as.numeric(dbGetQuery(con,'SELECT
COUNT(*)
FROM
"2017"'))
last_game_in_db
last_game_in_db <- as.numeric(dbGetQuery(con,'SELECT
COUNT(*)
FROM
"2017"'))
last_game_in_db
raw.data.18 = read.csv("http://www.football-data.co.uk/mmz4281/1718/E0.csv")
raw.data.18$Date = as.Date(raw.data.18$Date,"%d/%m/%y")
raw.data.18 = raw.data.18[order(raw.data.18$Date,raw.data.18$HomeTeam),]
raw.data.18$Date <- as.character(raw.data.18$Date)
last_game_available <- nrow(raw.data.18)
last_game_available
new_games_for_db <- cbind(((last_game_in_db+1):last_game_available),raw.data.18[((last_game_in_db+1):last_game_available),])
new_games_for_db
add_matches=dbSendQuery(con, 'INSERT INTO "2017"
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ? )')
add_matches=dbSendQuery(con, 'INSERT INTO "2017"
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ? )')
add_matches=dbSendQuery(con, 'INSERT INTO "2017"
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ? )')
new_games_for_db
add_matches=dbSendQuery(con, 'INSERT INTO "2017"
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ? )')
con = dbConnect(RSQLite::SQLite(), dbname="historic_data/football.db")
last_game_in_db <- as.numeric(dbGetQuery(con,'SELECT
COUNT(*)
FROM
"2017"'))
raw.data.18 = read.csv("http://www.football-data.co.uk/mmz4281/1718/E0.csv")
raw.data.18$Date = as.Date(raw.data.18$Date,"%d/%m/%y")
raw.data.18 = raw.data.18[order(raw.data.18$Date,raw.data.18$HomeTeam),]
raw.data.18$Date <- as.character(raw.data.18$Date)
last_game_available <- nrow(raw.data.18)
if (last_game_in_db < last_game_available){
# Select the matches which are not in the database (based on the row count of the database table)
new_games_for_db <- cbind(((last_game_in_db+1):last_game_available),raw.data.18[((last_game_in_db+1):last_game_available),])
#Insert the new rows into the db 69 columns of which the first one is just the row number
add_matches=dbSendQuery(con, 'INSERT INTO "2017"
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ? )')
for (i in 1:nrow(new_games_for_db)){
dbBind(add_matches, unname(new_games_for_db[i,]))
}
# Clear result of the query
dbClearResult(add_matches)
}
dbDisconnect(con)
last_game_match_hist <- as.numeric(dbGetQuery(con,'SELECT
COUNT(*)
FROM
ENG_matches_hist'))
con = dbConnect(RSQLite::SQLite(), dbname="historic_data/football.db")
last_game_match_hist <- as.numeric(dbGetQuery(con,'SELECT
COUNT(*)
FROM
ENG_matches_hist'))
last_game_match_hist
count_lineup_hist <- as.numeric(dbGetQuery(con,'SELECT
COUNT(*)
FROM
ENG_match_lineup'))
count_lineup_hist
(last_game_available %% 380)
(count_lineup_hist %% 380)
bf_odds = give_bf_odds('ENG')
countyr='ENG'
if (country=="ENG"){
country="GB"
competitionId = 10932509
}else if (country=="DE"){
competitionId = 59
}
country='ENG'
if (country=="ENG"){
country="GB"
competitionId = 10932509
}else if (country=="DE"){
competitionId = 59
}
library("abettor")
require("RCurl")
require("jsonlite")
loginBF(username = "moneymanchezz@hotmail.com", password = "air1992Dwizgh?!", applicationKey = "FOzz0vtLaJpIe25v")
marketCat <- listMarketCatalogue(eventTypeIds = "1", marketCountries = country, marketTypeCodes = "MATCH_ODDS" , competitionIds = competitionId,
fromDate = (format(Sys.time(), "%Y-%m-%dT%TZ")),
toDate = (format(Sys.time() + 604800, "%Y-%m-%dT%TZ")))
bf_oddstable <- data.frame(Home=character(),
Away=character(),
H_odds=double(),
D_odds=double(),
A_odds=double(),
stringsAsFactors=FALSE)
for (i in 1:length(marketCat[,1])){
ourSpecificRace <- marketCat[i,]
# selecting home and away team
ourMarketId=ourSpecificRace$marketId
teams=ourSpecificRace$runners[[1]]
homeid=teams$selectionId[1]
awayid=teams$selectionId[2]
drawid=teams$selectionId[3]
hometeam=ourSpecificRace$runners[[1]]$runnerName[1]
awayteam=ourSpecificRace$runners[[1]]$runnerName[2]
# To get team names similar to already used teamnames in main script
BF.names=c("Arsenal","Aston Villa","Birmingham","Blackburn","Blackpool","Bolton","Bournemouth","Bradford","Brighton","Burnley","Cardiff","Charlton","Chelsea","Coventry","C Palace","Derby","Everton","Fulham","Huddersfield","Hull","Ipswich","Leeds","Leicester","Liverpool","Man City","Man Utd","Middlesbrough","Newcastle","Norwich","Portsmouth","QPR","Reading","Sheffield United","Southampton","Stoke","Sunderland","Swansea","Tottenham","Watford","West Brom","West Ham","Wigan","Wolves","Wimbledon")
team.names=c("Arsenal","AstonVilla","Birmingham","Blackburn","Blackpool","Bolton","Bournemouth","Bradford","Brighton","Burnley","Cardiff","Charlton","Chelsea","Coventry","CrystalPalace","Derby","Everton","Fulham","Huddersfield","Hull","Ipswich","Leeds","Leicester","Liverpool","ManCity","ManUnited","Middlesbrough","Newcastle","Norwich","Portsmouth","QPR","Reading","Sheffield United","Southampton","Stoke","Sunderland","Swansea","Tottenham","Watford","WestBrom","WestHam","Wigan","Wolves","Wimbledon")
hometeam=team.names[which(BF.names==hometeam)]
awayteam=team.names[which(BF.names==awayteam)]
# getting time of the match
MatchTime <- ourSpecificRace$event$openDate
# looking for the prices
ourMarketIdPrices <- listMarketBook(marketIds = ourMarketId, priceData = "EX_ALL_OFFERS")
allRunnersPrices <- ourMarketIdPrices$runners
homeIdPrices <- allRunnersPrices[[1]][which(allRunnersPrices[[1]]$selectionId == homeid),]
drawIdPrices <- allRunnersPrices[[1]][which(allRunnersPrices[[1]]$selectionId == drawid),]
awayIdPrices <- allRunnersPrices[[1]][which(allRunnersPrices[[1]]$selectionId == awayid),]
# get Back odds and sizes (not lay)
homeIdPricesDF <- data.frame(homeIdPrices$ex[[1]])
drawIdPricesDF <- data.frame(drawIdPrices$ex[[1]])
awayIdPricesDF <- data.frame(awayIdPrices$ex[[1]])
# get best odds
bf_hodds <- homeIdPricesDF[1,1]
bf_dodds <- drawIdPricesDF[1,1]
bf_aodds <- awayIdPricesDF[1,1]
# create dataframe with BF odds
match_details=data.frame(hometeam,awayteam,bf_hodds,bf_dodds,bf_aodds,MatchTime)
names(match_details)=c("HomeTeam","AwayTeam","BF_H_odds","BF_D_odds","BF_A_odds","Date")
# add this as a row to the created dataframe
bf_oddstable <- rbind(bf_oddstable,match_details)
}
length(marketCat[,1])
marketCat
nrow(marketCat)!=0
give_bf_odds('ENG')!=0
if(!exists("foo", mode="function")) source("give_bf_odds.R")
if(!exists("foo", mode="function")) source("give_bf_odds.R")
give_bf_odds('ENG')
give_bf_odds('ENG')!=0
